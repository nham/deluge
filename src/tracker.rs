use metainfo::MetaInfo;

use hyper::Client;
use hyper::header::Connection;
use openssl::crypto::hash as openssl_hash;
use std::io::Read;

type Sha1Hash = Vec<u8>;

enum EventType {
    Started,
    Stopped,
    Completed,
    Empty,
}

struct TrackerRequest {
    // sha1 hash of the value of "info key from the Metainfo file". value will be a dict?
    info_hash: Sha1Hash,

    // length 20 string, generated by client to use as its id
    peer_id: String,

    // port number client is listening on
    port: u16,

    // total number of bytes uploaded by client since client sent `started` event
    uploaded: u64,

    // total number of bytes downloaded by client since blah blah blah
    downloaded: u64,

    // number of bytes that remain to be downloaded by the client
    left: u64,

    // whether client accepts a compact response
    compact: Option<bool>,

    // indicates tracker can omit peer ids in the peers dict.
    // ignored if `compact` is true
    no_peer_id: Option<bool>,

    event: Option<EventType>,
}

impl TrackerRequest {
    fn new(peer_id: String, port: u16, ul: u64, dl: u64,
           left: u64, info_hash: Sha1Hash) -> TrackerRequest {
        TrackerRequest {
            info_hash: info_hash,
            peer_id: peer_id,
            port: port,
            uploaded: ul,
            downloaded: dl,
            left: left,
            compact: None,
            no_peer_id: None,
            event: None,
        }
    }

    fn get_query_string(&self) -> String {
        let mut v = Vec::new();
        v.push(format!("{}={:?}", "info_hash", self.info_hash));
        v.push(format!("{}={}", "left", self.left));
        v.push(format!("{}={}", "uploaded", self.uploaded));
        v.push(format!("{}={}", "downloaded", self.downloaded));
        //v.push(format!("{}={}", "event", self.event));
        v.push(format!("{}={}", "port", self.port));
        v.push(format!("{}={}", "peer_id", self.peer_id));
        v.connect("&")
    }
}

pub fn get_tracker(metainfo: &MetaInfo) {
    // Create a client.
    let client = Client::new();

    let info_hash = openssl_hash::hash(openssl_hash::Type::SHA1,
                                       &metainfo.info_hash_bytes()[..]);
    let req = TrackerRequest::new(String::from("1234567890abcdefghij"), 4567, 0, 0,
                                  metainfo.piece_length() as u64, info_hash);

    println!("TrackerRequest: {:?}", req.get_query_string());

    // Creating an outgoing request.
    let send = client.get(&metainfo.announce)
                     .header(Connection::close())
                     .send();
    let mut res = match send {
        Ok(res) => res,
        Err(e) => return panic!("Error: {:?}", e),
    };

    // Read the Response.
    let mut body = String::new();
    res.read_to_string(&mut body).unwrap();

    println!("Response: {}", body);
}
